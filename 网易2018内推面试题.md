时间限制：1秒
空间限制：32768K

小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。)
例如: s = "ABAB",那么小易有六种排列的结果:
"AABB","ABAB","ABBA","BAAB","BABA","BBAA"
其中只有"AABB"和"BBAA"满足最多只有一对不同颜色的相邻砖块。

输入描述:
输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s中的每一个字符都为一个大写字母(A到Z)。

输出描述:
输出一个整数,表示小易可以有多少种方式。

输入例子1:
ABAB

输出例子1:
2

算法如下：
int getMaxSize(char* str, int length)
{
    int result[26] = {0};
    //先获取字母重复出现的次数
    for(int i = 0; i < length; ++i)
    {
        ++(result[str[i] - 'A']);
    }

    //统计一共有多少字母出现
    int count = 0;
    for(int i = 0; i < 26; ++i)
    {
        if(result[i] != 0)
        {
            ++count;
        }
    }

    //只有当有一种或两种字母，才会有一种或者两种结合；否则没有合适的结合
    if(count == 1 || count == 2)
        return count;
    else
        return 0;
}

等差数列
char* isArithmeticProgression(int length, int a[])
{
    //先排序
    for(int i = 0; i < length; ++i)
    {
        for(int j = i; j < length; ++j)
        {
            if(a[j] < a[i])
            {
                int temp = a[j];
                a[j] = a[i];
                a[i] = temp;
            }
        }
    }

    //求前后的差
    int pre = 0;
    for(int i = 1; i < length; ++i)
    {
        if(pre == 0)
        {
            pre = a[i] - a[i - 1];
        }
        else if(pre != a[i] - a[i - 1])
        {
            return "Impossible";
        }
    }
    return "Possible";
}